---
.title = "Home",
.date = "2020-07-06T00:00:00",
.author = "Loris Cro",
.draft = false,
.layout = "index.shtml",
.tags = [],
.custom = {
    "main-sample": 
        \\.id = .uuid("..."),
        \\.time = 631148400,
        \\.payload = .command(.{
        \\  .do = .clear_chat,
        \\  .sender = "kristoff-it",
        \\  .roles = ["admin", "mod"],
        \\  .extra = {
        \\    "agent": "Mozilla/5.0",
        \\    "os": "Linux/x64", 
        \\  }),
        \\}
    ,
    "package-schema": 
        \\$ = Package
        \\
        \\struct Package {
        \\  name: bytes,
        \\  version: bytes,
        \\  license: License,
        \\  description: bytes,
        \\  dependencies: {:}bytes,
        \\  repository: Repository,
        \\
        \\}
        \\
        \\union License {
        \\  /// Valid SPDX identifier 
        \\  spdx: bytes,
        \\  /// URL to license definition
        \\  custom: bytes
        \\} 
        \\
        \\union Repository {
        \\  git: Git,
        \\  npm: Npm,
        \\
        \\  struct Git { url: bytes, directory: ?bytes }
        \\  struct Npm { name: bytes }
        \\}
    ,
    "message-schema": 
        \\$ = Message
        \\
        \\struct Message {
        \\  id: Id,
        \\  time: int,
        \\  payload: Payload,
        \\
        \\  union Id { uuid: bytes, seq: int }
        \\  union Payload {
        \\    command: Command,
        \\    notification: Notification, 
        \\
        \\    struct Command {
        \\      do: Action,
        \\      sender: bytes,
        \\      roles: []bytes,
        \\      /// Optional metadata. 
        \\      extra: ?{:}bytes,
        \\   
        \\      union Action { clear_chat, ban_user: bytes }
        \\    }
        \\
        \\    struct Notification { text: bytes, lvl: int }
        \\  }
        \\}
    ,
    "cli": 
        \\$ ziggy help
        \\
        \\Usage: ziggy COMMAND [OPTIONS]
        \\
        \\Commands: 
        \\  fmt          Format Ziggy files      
        \\  query, q     Query Ziggy files 
        \\  check        Check Ziggy files against a Ziggy schema 
        \\  convert      Convert between JSON, YAML, TOML files and Ziggy
        \\  lsp          Start the Ziggy LSP
        \\  help         Show this menu and exit
        \\
        \\General Options:
        \\  --help, -h   Print command specific usage
        \\
    ,
    "package-json": 
        \\{
        \\  "name": "ziggy",
        \\  "version": "1.0.0",
        \\  "license": "MIT",
        \\  "dependencies": {
        \\    "react": "next",
        \\    "leftpad": "^1.0.0"
        \\  },
        \\  "repository": {
        \\    "type": "git",
        \\    "url" : "https://github.com"
        \\ },
        \\  "description": 
        \\    "# Ziggy\n\nA Data Serializa..."
        \\
        \\
        \\
        \\}
    ,
    "package-ziggy": 
        \\{
        \\  .name = "ziggy",
        \\  .version = "1.0.0",
        \\  .license = .spdx("MIT"),
        \\  .dependencies = {
        \\    "react": "next",
        \\    "leftpad": "^1.0.0",
        \\  },
        \\  .repository = .git(.{
        \\    // "type" is now the union case
        \\    .url = "https://github.com",
        \\  }),
        \\  .description = 
        \\    \\# Ziggy
        \\    \\
        \\    \\A Data Serialization Language.
        \\  ,
        \\}
    ,
}
--- 

[]($section.id('first-section'))
## Notation designed to help users grok data layouts
### Structs vs Dictionaries
Ziggy has two notations for key-value pairs. Structs are for when valid keys are specified in a Ziggy Schema, and dictionaries are for when key names are up to the user.

This helps users get a better intuition for the schema before they even see it, and it also offers affodances like knowing when it makes sense to "goto definition" on a field.

### Tagged Unions

**Ever had to fight JSON to express a tagged union?**
Ziggy structs have names that can be used by both humans and tooling
to discriminate between union cases.

### ...and more quality of life features!

Optional top-level curlies, multi-line string literals, trailing commas, comments, underscores in numeric literals, etc.

See an example `package.json` vs a (hypothetical) Ziggy version.

[]($section.id('second-section'))
## A schema language for creating and documenting clear data layouts
  Ziggy schemas help you define data layouts that are easy to grasp and
  validate for correctness. Ziggy schemas can define struct unions, enums
  and custom string literals.

  The Ziggy LSP will be able to use your schema definitions to show
  diagnostics, contextual help and give autocomplete suggestions to your
  users.

  Other tooling will be able to use schemas to autogenerate compatible
  type definitions.

  The best feature of Ziggy schemas is that
[they
    **can't**
    define
    every possible
    data layout!]($link.page('documentation/unions'))



[]($section.id('third-section'))
## Tooling Supremacy
One official CLI tool that solves the most common needs, like **auto-formatting**, **schema validation**, **format conversion**, **querying** (coming soon) and **LSP support** for comfortable editing in your favorite text editor or IDE.

