---
.title = "Parser Example",
.date =  "2025-03-10T19:11:59",
.author = "LowByteFox",
.draft = false,
.layout = "documentation.shtml",
.tags = [],
---

# Parser Example
First import `ziggy` (see [Getting Started](getting-started-dev) to learn how to add Ziggy as a dependency):
```zig
const ziggy = @import("ziggy");
```

Ziggy has two main parser APIs:
- `ziggy.Ast`, which allows you to parse a Ziggy file into an AST, useful when
  doing source-level analysis of Ziggy documents.
- `ziggy.Deserializer`, a type-driven parser that allows you to parse a Ziggy
  document either into a known type defined by you, or into a `ziggy.Dynamic` (a
  type able to represent any Ziggy document).

The AST parser is a bit of a specialty parser so we won't expand on it in this
document.

## Deserializing a Zig value
First, define a type you want Ziggy document to reflect

```zig
const Example = struct {
    foo: []const u8,
    bar: bool,
};
```

Then call `ziggy.deserializeLeaky` to obtain an instance of `Example`

```zig
var meta: ziggy.Deserializer.Meta = .init;
const example = try ziggy.deserializeLeaky(Example, allocator, str, &meta, .{});
```
Now you can access the data through the returned value.

In case of error, see the documentation of `deserializeLeaky` to learn how to
properly report it to the user.

The last parameter is an instance of `ziggy.Deserializer.Options` and can define
more parsing options.

Parsing a Ziggy document might require to heap allocate values (e.g. to unescape
a string), and it's normally problematic to keep track of such occurrences,
meaning that you should use a `std.heap.ArenaAllocator` (or equivalents) in order
to prevent memory leakages (hence the `Leaky` part of the function name).

For convenience you can use `ziggy.deserialize`, which will automatically bundle
the result value in a type that includes an arena allocator. Make sure to call
`deinit` on the returned value to free all related memory.
