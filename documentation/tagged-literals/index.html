<!DOCTYPE html>
<html>
	<head id="head">
		<meta charset="UTF-8">
		<meta name="color-scheme" content="light dark">
		<meta name="description" content="Ziggy: A JSON/YAML/TOML alternative.">
		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@croloris">
		<meta name="twitter:author" content="@croloris">
		<meta name="twitter:description" content="Ziggy: A JSON/YAML/TOML alternative.">
		<meta name="twitter:title" content="Tagged Literals - Ziggy">
		<meta property="og:title" content="Tagged Literals">
		<meta property="og:type" content="website">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<title id="title">
			Tagged Literals
			- Ziggy Data Language
		</title>
		<link rel="stylesheet" type="text/css" href="/fonts.css">
		<link rel="stylesheet" type="text/css" href="/style.css">
		<link rel="stylesheet" type="text/css" href="/highlight.css">
		
	<style>
		#content {
			display: flex;
			flex-direction: row;
			gap: 20px;
		}
		
		#sidebar {
			flex: 0 0 260px;
			padding-top: 0.67em;
		}
		
		#sidebar details {
			list-style: none;
		}
		
		#sidebar summary {
			border-top: 1px solid var(--border-color);
			list-style: none;
			padding: 10px 0;
			color: #333;
			font-weight: bold;
			padding-left: 10px;
		}
		
		#sidebar summary:hover {
			color: #111;
			background-color: #eee;
		}
		
		#sidebar ul {
			list-style: none;
			padding: 0;
			margin: 0 0 10px;
		}
		
		#sidebar a {
			display: block;
			text-decoration: none;
			padding: 5px 0;
			color: inherit;
			padding-left: 10px;
		}
		
		#sidebar a:hover, #sidebar .selected {
			background-color: #ddd;
		}
		
		#sidebar-content {
			position: sticky;
			top: 110px;
		}
		
		#footer {
			display: flex;
			flex-direction: row;
			justify-content: space-between;
			width: 100%;
			margin-top: 50px;
			border-top: 1px solid var(--border-color);
			text-align: right;
		}
		
		#footer a {
			text-decoration: none;
			color: inherit;
		}
		
		#footer .title {
			font-weight: bold;
			color: #222;
			text-decoration: underline;
		}
		
		#main {
			max-width: 920px;
			flex-grow: 1;
		}
		
		#main h2 {
			margin-top: 1.5em;
			border-bottom: 2px dotted #aaa;
		}
		
		pre {
			margin: 10px;
			padding: 0;
			border: 1px dashed;
			border-radius: 0;
		}
		
		pre code {
			display: block;
			padding: 30px;
			padding-top: 0;
			padding-right: 0;
		}
		
		p code {
			background-color: #333;
			border-radius: 4px;
			color: white;
			padding: 0.2em;
		}
		
		pre::before {
			display: block;
			content: "Shell";
			background-color: #fff;
			font-family: "Epilogue", sans-serif;
			font-size: 0.7em;
			color: #555;
			padding: 10px;
			padding-left: 15px;
			padding-top: 12px;
			text-transform: uppercase;
			margin-bottom: 30px;
			position: sticky;
			top: 0;
			left: 0;
			z-index: 10;
		}
		
		pre:has(> code.markdown):before {
			content: "Markdown";
		}
		
		pre:has(> code.javascript):before {
			content: "JavaScript";
		}
		
		pre:has(> code.zig):before {
			content: "Zig";
		}
		
		pre:has(> code.lua):before {
			content: "Lua";
		}
		
		pre:has(> code.toml):before {
			content: "TOML";
		}
		
		pre:has(> code.json):before {
			content: "JSON";
		}
		
		pre:has(> code.ziggy):before {
			content: "Ziggy Document";
		}
		
		pre:has(> code.ziggy-schema):before {
			content: "Ziggy Schema";
		}
		
		@media (prefers-color-scheme: dark) {
			#sidebar summary {
				border-color: var(--border-color);
				color: #eee;
			}
			
			#sidebar summary:hover {
				color: var(--text-color);
				background-color: #ffffff11;
			}
			
			#sidebar a:hover, #sidebar .selected {
				background-color: #ffffff33;
			}
			
			#footer .title {
				color: var(--text-color);
			}
			
			#main h2 {
				border-color: #aaa;
			}
			pre::before {
				background-color: #ffffff22;
				color: var(--text-color);
			}
		}
		
		@media (max-width: 1000px) {
			#content {
				padding: 0 15px;
				flex-direction: column-reverse;
			}
			
			#main {
				max-width: 1000px;
			}
			
		}
		
		#insanity {
			max-height: 400px;
			overflow-y: scroll;
		}
	</style>

	</head>
	<body id="body">
		<nav id="top-nav">
			<div id="top-nav-container">
				<span>
					<a href="/"
					   style="font-size: 1.8em;font-family:'Glue Gun';font-weight:bold;text-decoration: none; color: light-dark(black, white);"
					>Ziggy</a>
					<span>v0.0.1</span>
				</span>
				<div id="top-nav-menu">
					<a href="/documentation/getting-started/">
						Quickstart
					</a>
					<a href="/documentation/about/">
						Documentation
					</a>
					<a href="/log/">
						Changelog
					</a>
					<a href="https://github.com/kristoff-it/ziggy" target="_blank">
						Code
					</a>
				</div>
			</div>
		</nav>
		
	<div id="content">
		<nav id="sidebar">
			<div id="sidebar-content">
				<details open>
					<summary>Overview</summary>
					<ul>
						<li>
							<a class="" href="/documentation/about/">About</a>
						</li>
					
						<li>
							<a class="" href="/documentation/getting-started/">Getting Started</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Editor Configuration</summary>
					<ul>
						<li>
							<a class="" href="/documentation/editors/vscode/">VSCode</a>
						</li>
					
						<li>
							<a class="" href="/documentation/editors/neovim/">Neovim</a>
						</li>
					
						<li>
							<a class="" href="/documentation/editors/helix/">Helix</a>
						</li>
					
						<li>
							<a class="" href="/documentation/editors/flow/">Flow</a>
						</li>
					
						<li>
							<a class="" href="/documentation/editors/emacs/">Emacs</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Ziggy Document</summary>
					<ul>
						<li>
							<a class="" href="/documentation/scalars/">Scalar Values</a>
						</li>
					
						<li>
							<a class="" href="/documentation/containers/">Container Values</a>
						</li>
					
						<li>
							<a class="" href="/documentation/document/">Document Structure</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Ziggy Schema</summary>
					<ul>
						<li>
							<a class="" href="/documentation/builtin-types/">Builtin Types</a>
						</li>
					
						<li>
							<a class="" href="/documentation/custom-types/">Custom Types</a>
						</li>
					
						<li>
							<a class="" href="/documentation/schema-structure/">Schema Structure</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Design Tips</summary>
					<ul>
						<li>
							<a class="" href="/documentation/struct-unions/">Struct Unions</a>
						</li>
					
						<li>
							<a class="selected" href="/documentation/tagged-literals/">Tagged Literals</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Libraries</summary>
					<ul>
						<li><a href="/documentation/parsers/">Parsers</a></li>
					</ul>
				</details>
				<details open>
					<summary>Using Ziggy from Zig</summary>
					<ul>
						<li>
							<a class="" href="/documentation/getting-started-dev/">Getting Started</a>
						</li>
					
						<li>
							<a class="" href="/documentation/parser-example/">Parser Example</a>
						</li>
					
						<li>
							<a class="" href="/documentation/frontmatter/">Frontmatter</a>
						</li>
					
						<li>
							<a class="" href="/documentation/serialization-example/">Serialization Example</a>
						</li>
					
						<li>
							<a class="" href="/documentation/metaprogramming/">Metaprogramming</a>
						</li>
					</ul>
				</details>
				<details open>
					<summary>Ziggy CLI Tool</summary>
					<ul>
						<li>
							<a class="" href="/documentation/ziggy-fmt/">ziggy fmt</a>
						</li>
					
						<li>
							<a class="" href="/documentation/ziggy-query/">ziggy query</a>
						</li>
					
						<li>
							<a class="" href="/documentation/ziggy-check/">ziggy check</a>
						</li>
					
						<li>
							<a class="" href="/documentation/ziggy-convert/">ziggy convert</a>
						</li>
					
						<li>
							<a class="" href="/documentation/ziggy-lsp/">ziggy lsp</a>
						</li>
					</ul>
				</details>
				<details>
					<summary>Specification</summary>
					<ul>
						<li>
							<a class="" href="/documentation/spec/">Specification</a>
						</li>
					</ul>
				</details>
			</div>
		</nav>
		<div id="main">
			<div><h1>Tagged Literals</h1><p>In the previous page we discussed struct unions, which come with some benefits for humans and also some benefits for parsers, especially when it comes statically typed, compiled languages.</p><p>Tagged literals also bring their own set of benefits for users but in some ways are the inverse of struct unions, as they mainly cater to dynamically typed languages.</p><h2>What are tagged literals for?</h2><p>Tagged literals offer two main benefits:</p><ul><li>give a hint to the user about expected data formats</li><li>help parsers map strings to other data types</li></ul><p>It is important to understand these benefits in the context of a fully fledged use case, otherwise we risk overusing (or underusing) this tool.</p><h2>Use Case: Chat Message</h2><p>Consider this very simple chat message example:</p><pre><code class="ziggy">.<span class="keyword">sent_at</span> = <span class="string">&quot;2024-01-01T00:00:00&quot;</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">text</span> = <span class="string">&quot;hello world&quot;</span><span class="punctuation_delimiter">,</span>
</code></pre>
<p>Should <code>date</code> be turned into a tagged literal? Let’s look at the practical implications of doing so to make a decision.</p><ul><li><p><strong>No</strong> tagged literal</p><pre><code class="ziggy-schema"><span class="keyword">root</span> = <span class="type">Message</span> 

<span class="keyword">struct</span> <span class="type">Message</span> <span class="punctuation_bracket">{</span>
  <span class="comment_line_documentation">///A RFC3339 date string, eg `2024-01-01T00:00:00`</span>
  <span class="keyword type">sent_at</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Message contents</span>
  <span class="keyword type">text</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>
</code></pre>
</li><li><p>Tagged literal</p><pre><code class="ziggy-schema"><span class="keyword">root</span> = <span class="type">Message</span> 

<span class="comment_line_documentation">///A RFC3339 date string, eg `2024-01-01T00:00:00`</span>
<span class="function">@date</span> = <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>

<span class="keyword">struct</span> <span class="type">Message</span> <span class="punctuation_bracket">{</span>
  <span class="keyword type">sent_at</span>: <span class="function">@date</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Message contents</span>
  <span class="keyword type">text</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>
</code></pre>
</li></ul><p>As you can see, in this very simple case there isn’t much to gain by introducing a tagged literal.</p><p>This is mainly caused by the fact that there is only one field that holds a date, so we ended up moving the docstring from one place to the other, with little difference to the overall result.</p><p>It should be noted that looking at how this choice influences the resulting Ziggy Schema does not tell you the full picture, and in fact later on we will focus on parsing, but for now let’s keep looking at Ziggy Schemas a bit more.</p><p>Let’s take a look now at an example where a date literal would be more compelling.</p><h2>Use Case: Job Posting</h2><p>Consider this Ziggy document:</p><pre><code class="ziggy">.<span class="keyword">title</span> = <span class="string">&quot;Hot Startup wants Senior Zig Engineer&quot;</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">creation_date</span> = @<span class="function">date</span><span class="punctuation_bracket">(</span><span class="string">&quot;2024-01-01&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">publish_date</span> = @<span class="function">date</span><span class="punctuation_bracket">(</span><span class="string">&quot;2024-01-10&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">expiry_date</span> = @<span class="function">date</span><span class="punctuation_bracket">(</span><span class="string">&quot;2024-02-10&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">text</span> = <span class="string">&quot;Hot Startup...&quot;</span><span class="punctuation_delimiter">,</span>
</code></pre>
<p>Let’s look again at the schema with and without tagged literals:</p><ul><li><p><strong>No</strong> tagged literal</p><pre><code class="ziggy-schema"><span class="keyword">root</span> = <span class="type">Message</span> 

<span class="keyword">struct</span> <span class="type">Message</span> <span class="punctuation_bracket">{</span>
  <span class="comment_line_documentation">///Title of this job posting</span>
  <span class="keyword type">title</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting was created, in &apos;YYYY-MM-DD&apos; format.</span>
  <span class="keyword type">creation_date</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting becomes visible, in &apos;YYYY-MM-DD&apos; format.</span>
  <span class="keyword type">publish_date</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting goes offline, in &apos;YYYY-MM-DD&apos; format.</span>
  <span class="keyword type">expiry_date</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Main content</span>
  <span class="keyword type">text</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>
</code></pre>
</li><li><p>Tagged literal</p><pre><code class="ziggy-schema"><span class="keyword">root</span> = <span class="type">Message</span> 

<span class="comment_line_documentation">///A date in &apos;YYYY-MM-DD&apos; format.</span>
<span class="function">@date</span> = <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>

<span class="keyword">struct</span> <span class="type">Message</span> <span class="punctuation_bracket">{</span>
  <span class="comment_line_documentation">///Title of this job posting</span>
  <span class="keyword type">title</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting was created.</span>
  <span class="keyword type">creation_date</span>: <span class="function">@date</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting becomes visible.</span>
  <span class="keyword type">publish_date</span>: <span class="function">@date</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Date this job posting goes offline.</span>
  <span class="keyword type">expiry_date</span>: <span class="function">@date</span><span class="punctuation_delimiter">,</span>
  <span class="comment_line_documentation">///Main content</span>
  <span class="keyword type">text</span>: <span class="constant_builtin">bytes</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>
</code></pre>
</li></ul><p>In contrast with the Chat message use case, this second example shows how by creating a dedicated tagged literal to express dates, we were able to collect all repeated date format requirements into one place.</p><h2>Parsing From Dynamic Languages</h2><p>In the “Struct Unions” page we mentioned how statically typed, compiled languages benefit from Ziggy struct unions more than dynamic languages.</p><p>If those kind of languages aim to approximate optimal behavior from the machine, dynamic languages in contrast are more about letting the programmer leave details unstated in order to achieve faster development speed.</p><p>One clear example of this difference is how in Zig (statically typed, compiled and generally low-level) the programmer always wants to have a type definition for Ziggy data layouts, while in JavaScript (dynamic, interpreted, high-level) one can easily get away with parsing Ziggy documents on the fly.</p><p>And it’s in this second scenario that string literals offer the right amount of typization.</p><p>Ziggy doesn’t have yet a JavaScript parser library, so the following code is not a <em>concrete</em> example, but it’s still a valid way of showing how tagged literals are useful in that scenario:</p><pre><code class="javascript"><span class="comment">// Imaginary &quot;ziggy&quot; package.</span>
<span class="keyword">const</span> <span class="constructor constant variable_builtin function_builtin variable">ziggy</span> <span class="operator">=</span> <span class="constructor constant variable_builtin function_builtin variable function">require</span><span class="punctuation_bracket">(</span><span class="string">&quot;ziggy&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>

<span class="keyword">const</span> <span class="constructor constant variable_builtin function_builtin variable">posting</span> <span class="operator">=</span> <span class="constructor constant variable_builtin function_builtin variable">ziggy</span><span class="punctuation_delimiter">.</span><span class="property function_method">parse</span><span class="punctuation_bracket">(</span><span class="string">&quot;posting.ziggy&quot;</span><span class="punctuation_delimiter">,</span> <span class="punctuation_bracket">{</span>
  <span class="comment">// Date.parse accepts an ISO8601 date string </span>
  <span class="comment">// and returns a date instance.</span>
  <span class="property">literals</span>: <span class="punctuation_bracket">{</span> <span class="property">date</span>: <span class="constructor constant variable_builtin function_builtin variable">Date</span><span class="punctuation_delimiter">.</span><span class="property">parse</span> <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<p>With just one (imaginary but plausible) line we were able to parse dates correctly. Without a date literal, it wouldn’t be this easy.</p><h2>Not Just Dynamic Languages</h2><p>The example given just now revolved around the ability to recognize dates (as an example of tagged literal) inside of an unknown data layout. In that example, what made the data layout “unknown” was the interest in leaving it unspecified inside of a JavaScript application.</p><p>There is one last situation worth considering that involves unknown layouts: when a data layout accepts user-defined fields.</p><p>One prime example of this use case are frontmatters.</p><p>A frontmatter is a small section of metadata (usually expressed in YAML) placed at the top of Markdown files, usually consumed by static site generators while rendering the content into HTML files. This is what it looks like in <a href="https://zine-ssg.io" target="_blank">Zine</a>:</p><pre><code class="markdown">---
.title = &quot;Tagged Literals&quot;,
.date = @date(&quot;2024-03-20T00:00:00&quot;),
.author = &quot;Loris Cro&quot;,
.layout = &quot;documentation.html&quot;,
.draft = false,
---
<span class="punctuation_special">#</span> <span class="text_title">Tagged Literals</span>

Yadda yadda...
</code></pre>
<p>In Zine it’s also possible to specify custom fields inside of the frontmatter of each page, which can then be retrieved from the HTML layout in order to orchestrate rendering logic.</p><p>Let’s consider an example where we want to use Zine to render a ticket sales page (for simplicity let’s focus on the frontmatter itself):</p><pre><code class="ziggy">.<span class="keyword">title</span> = <span class="string">&quot;Buy Tickets&quot;</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">layout</span> = <span class="string">&quot;tickets.html&quot;</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">draft</span> = <span class="constant_builtin_boolean">false</span><span class="punctuation_delimiter">,</span>
.<span class="keyword">custom</span> = <span class="punctuation_bracket">{</span>
  <span class="string">&quot;sale_start&quot;</span>: @<span class="function">date</span><span class="punctuation_bracket">(</span><span class="string">&quot;2024-01-01T00:00:00&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
  <span class="string">&quot;sale_end&quot;</span>: @<span class="function">date</span><span class="punctuation_bracket">(</span><span class="string">&quot;2024-04-01T00:00:00&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span><span class="punctuation_delimiter">,</span>
</code></pre>
<p>In this case <code>sale_start</code> and <code>sale_end</code> are two custom fields provided by the user that don’t belong to the Zine frontmatter schema.</p><p>This means that even though Zine is an application written in Zig, for all intents and purposes, we are in a similar situation to where JavaScript was, when it comes to parsing contents of the <code>custom</code> field.</p><p>Zine leverages tagged unions in order to recognize when a user-provided field is meant to represent a date, which brings a couple practical benefits:</p><ul><li>the user doesn’t have to parse a date out of a string every time they want to access custom date fields</li><li>a malformed date will result in a frontmatter parsing error, instead of a template evaluation error</li></ul><h2>Concrete Tips</h2><p>The golden rule of tagged literals (and maybe of a few other things as well):</p><p><strong>Abstract purity doesn’t belong in engineering.</strong>,</p><p><strong>Resist always the temptation of creating tagged literals for abstract reasons. Always think of the practical implications and act exclusively in accordance to the intent of achieving a practical outcome.</strong></p><h3>Manual editing or automated generation?</h3><p>If your Ziggy data layout is going to be edited by humans manually (e.g. it’s a config file format), then they might benefit from the <a href="https://en.wikipedia.org/wiki/Affordance" target="_blank">affordance</a> offered by a tagged literal, like dedicated documentation and autocomplete suggestions. Although you should also keep in mind that if your literal is only used in one place, then a field doc comment might suffice (like in the chat message use case).</p><p>If your data layouts are instead designed to be consumed by programs (e.g. API messages), then the previous point become much weaker and you will want to leverage other considerations in order to make a final decision.</p><h3>Who will consume your data layout?</h3><p>If your Ziggy data layout might be consumed by clients implemented in dynamic languages, they might want to parse your Ziggy documents without hardcoding a schema in their code, and in that case tagged literals could help them improve their parsing experience.</p><p>If your data layouts are instead going to be consumed exclusively by statically typed, compiled, low-level languages, then you will want to leverage other considerations in order to make a final decision.</p><h3>Do you have user-provided fields?</h3><p>If you Ziggy data layout accepts user-provided fields, and users are allowed to input strings that represent types understood by your application (e.g. dates) then you have a good reason to defne those types as tagged literals.</p><p>It should be noted that this last point should still be evaluated in light of the “avoid abstract purity” principle. It’s often the case that applications must deal with many literals, like <code>@url</code> or <code>@path</code> for example, but that doesn’t immediately mean that one should create literals for each.</p><p>The Zine frontmatter example was relevant precisely because by recognizing dates early the user experience got improved. If creating a tagged literal for a type doesn’t trigger the same kind of practical improvement, it might be best to prefer creating a simpler schema in order to gain the very real benefit of lowering the cognitive load on your users.</p></div>
			<nav id="footer">
				<div>
					<a href="/documentation/struct-unions/">
						<p>
							←
							<span class="title">Struct Unions</span>
						</p>
					</a>
				</div>
				<div>
					<a href="/documentation/parsers/">
						<p>
							<span class="title">Parsers</span>
							→
						</p>
					</a>
				</div>
			</nav>
		</div>
	</div>

	</body>
</html>
